<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns="http://membrane-soa.org/proxies/1/"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:beans="http://www.springframework.org/schema/beans"
            targetNamespace="http://membrane-soa.org/proxies/1/"
            elementFormDefault="qualified" attributeFormDefault="unqualified">

    <!-- Automatically generated by com.predic8.membrane.annot.generator.Schemas. -->

    <xsd:import namespace="http://www.springframework.org/schema/beans" schemaLocation="http://www.springframework.org/schema/beans/spring-beans-3.1.xsd" />

    <xsd:simpleType name="spel_number">
        <xsd:restriction base="xsd:string">
            <xsd:pattern value="-?[0-9]+|\#\{.*\}|\$\{.*\}"></xsd:pattern>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:simpleType name="spel_boolean">
        <xsd:restriction base="xsd:string">
            <xsd:pattern value="[01]|true|false|\#\{.*\}|\$\{.*\}"></xsd:pattern>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:element name="amQuota">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="amRateLimiter">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="amStatisticsCollector">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="host" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="clientId" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="clientSecret" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="accessControl">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                requested resource.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="file" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Location of the ACL file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; acl/acl.xml&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="accountBlocker">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
                system) after too many failed login attempts.
                &lt;/p&gt;
                &lt;p&gt;
                When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
                becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
                (writing 3600000 means "for 1 hour").
                &lt;/p&gt;
                &lt;p&gt;
                The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
                (writing 9223372036854775807 means "forever").
                &lt;/p&gt;
                &lt;p&gt;
                If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
                become blocked. (This is necessary to limit memory usage.)
                &lt;/p&gt;
                &lt;h3&gt;Discussion&lt;/h3&gt;
                &lt;p&gt;
                Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
                shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
                5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
                &lt;/p&gt;
                &lt;p&gt;
                The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
                one year is therefore about 56%.
                &lt;/p&gt;
                &lt;p&gt;
                Therefore, a more secure password should be chosen, containing letters, digits and special characters.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="blockWholeSystemAfter" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="afterFailedLogins" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="afterFailedLoginsWithin" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="blockFor" type="spel_number" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="adminConsole">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="readOnly" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether runtime changes to Membrane's configuration can be committed in the admin console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="apiKeyChecker">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="keyFile">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="header" type="com.predic8.membrane.core.config.spring.HeaderParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="allowSwagger" type="spel_boolean" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="apiManagement">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="amRateLimiter">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="amQuota">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="amStatisticsCollector">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="config" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the location of the configuration&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; api.yaml&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.AttributeParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="from" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="to" type="xsd:string" use="required">
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.LdapUserDataProvidermapParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="attribute" type="com.predic8.membrane.core.config.spring.AttributeParser">
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="authHead2Body">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.AuthenticationParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="username" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="password" type="xsd:string" use="required">
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ClustersParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="cluster" type="com.predic8.membrane.core.config.spring.ClusterParser">
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="basicAuthentication">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="user" type="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="bearerToken">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="byThreadStrategy">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="maxNumberOfThreadsPerEndpoint" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum number of concurrently running requests per endpoint.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="retryTimeOnBusy" type="spel_number" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="cache">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Don't use, this does NOT implement valid HTTP caching.
                &lt;/p&gt;
                &lt;p&gt;
                We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                the Docker Registry for offline use.
                The cache does not revalidate any responses, so machines querying the cache for Debian
                package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                This is - simply put - the only use case, where using this class makes any sense.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Don't use, this does NOT implement valid HTTP caching.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                    the Docker Registry for offline use.
                                    The cache does not revalidate any responses, so machines querying the cache for Debian
                                    package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                    This is - simply put - the only use case, where using this class makes any sense.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="fileStore">
                            </xsd:element>
                            <xsd:element ref="inMemoryStore">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.SwitchcaseParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="url" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Target URL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://predic8.com/fastorder&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="service" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="xPath" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; XPath expression.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; //fastorder/&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="certificate">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="claims">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:element name="scope" type="com.predic8.membrane.core.config.spring.ClaimsscopeParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="value" type="xsd:string" use="required">
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="clamav">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="host" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the host of the clamav daemon&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; localhost&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the port of the clamav daemon&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 3310&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.StaticClientListclientParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="clientId" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="clientSecret" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="callbackUrl" type="xsd:string" use="required">
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ClusterParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:element name="node" type="com.predic8.membrane.core.config.spring.NodeParser">
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="name" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the name of the cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Default&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="clusterNotification">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="validateSignature" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Set Push Interface to encrypted mode.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="timeout" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Timestamp invalidation period. (0=unlimited)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="keyHex" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Key used by encryption as hex string&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 6f488a642b740fb70c5250987a284dc0&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="if">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The "if" interceptor supports conditional execution of a group of executors.
                &lt;/p&gt;

                &lt;p&gt;
                Note that this is a draft implementation only: Design decissions are still pending.
                &lt;/p&gt;
                &lt;ul&gt;
                &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The "if" interceptor supports conditional execution of a group of executors.
                                    &lt;/p&gt;

                                    &lt;p&gt;
                                    Note that this is a draft implementation only: Design decissions are still pending.
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                    &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                    &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="language" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the language of the 'test' condition&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; groovy&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="test" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the condition to be tested&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; exc.request.header.userAgentSupportsSNI&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ConnectionParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="keepAliveTimeout" type="spel_number" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Time in milliseconds after which an open connection to the server is not reused. Be sure to set it to a smaller value than the KeepAlive
                            directive on your server. Note that the a "Keep-Alive" header in the response always takes precedence.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 4000&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="timeout" type="spel_number" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Socket timeout (connect, read, etc.) in milliseconds.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10000&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="localAddr" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The local IP address to use for outbound connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; not set&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="counter">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the name that will be displayed on the web page.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Mock Node 1&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="customStatementJdbcUserDataProvider">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="checkPasswordSql" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="sqlResultAttribute" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="userNameAttribute" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="datasource" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="tableName" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="userColumnName" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="passwordColumnName" type="xsd:string" use="required">
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="defaultConfig">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="dispatching">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                element to the list of destinations of the exchange object. It
                must be placed into the transport to make Service Proxies Work
                properly. It has to be placed after the ruleMatching
                interceptor. The ruleMatching interceptor looks up a service
                proxy for an incoming request and places it into the exchange
                object. The dispatching interceptor needs the service proxy to
                get information about the target.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="registration">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="elasticSearchExchangeStore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="client" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="updateIntervalMs" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="documentPrefix" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.EmailTokenProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="simulate" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; don't actually send emails, if set to true&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="recipient" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the recipient email address (templated)&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="body" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the email body (templated)&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="sender" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the sender email address (templated)&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="subject" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the email subject (templated)&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="smtpHost" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; SMTP host&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="smtpUser" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; SMTP user to use for sender authentication&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; don't authenticate&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="smtpPort" type="spel_number" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the SMTP port to use&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 25&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="smtpPassword" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the SMTP password to use for sender authentication&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="ssl" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; whether to use SMTP over SSL&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.EmptyTokenProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="etcdBasedConfigurator">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; port&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="baseUrl" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; URL for etcd&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "http://localhost:4001"&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="baseKey" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Key/Directory&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "/asa/lb"&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="etcdPublisher">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="baseUrl" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; URL for etcd&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "http://localhost:4001"&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="baseKey" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Key/Directory&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "/asa/lb"&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ttl" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; time to live of etcd data&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 300&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="etcdRegistryApiConfig">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="url" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the url to where details are published&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; http://localhost:4001&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ttl" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; ttl in seconds&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 300&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="etcdResolver">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="url" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="exchangeStore">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Bean name of the exchange store defined as a spring bean.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; forgetfulExchangeStore&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="exclude">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;excluding&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.FormValidationfieldParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="name" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Name of the form parameter.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; age&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="regex" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Java Regular expression&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; \d+&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="fileExchangeStore">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="dir" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Directory where the exchanges are saved.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; logs&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="raw" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If this is true, headers will always be printed (overriding
                                saveBodyOnly) and the body of the exchange won't be
                                formatted nicely.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="saveBodyOnly" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If this is true, no headers will be written to the exchange
                                log files.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxDays" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Number of days for which exchange logs are preserved. A
                                value smaller than zero deactivates the deletion of old
                                logs.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 60&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="fileStore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="dir" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="forgetfulExchangeStore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="formValidation">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="field" type="com.predic8.membrane.core.config.spring.FormValidationfieldParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.GithubParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0">
                        <xsd:element ref="ssl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:any namespace="##other" processContents="strict" />
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="httpClientConfiguration" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="clientId" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="clientSecret" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="scope" type="xsd:string" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.GoogleParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0">
                        <xsd:element ref="ssl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:any namespace="##other" processContents="strict" />
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="httpClientConfiguration" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="clientId" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="clientSecret" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="scope" type="xsd:string" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="groovy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="groovyTemplate">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="http2xml">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="httpClient">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                Server using the HTTP protocol. Usually it will be globally used
                inside the transport. However, it is also possible to use it
                inside a proxy to give the proxy an individual configuration for
                its outgoing HTTP connection that is different from the global
                configuration in the transport.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                    Server using the HTTP protocol. Usually it will be globally used
                                    inside the transport. However, it is also possible to use it
                                    inside a proxy to give the proxy an individual configuration for
                                    its outgoing HTTP connection that is different from the global
                                    configuration in the transport.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="httpClientConfig">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="failOverOn5XX" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to retry again (possibly the next node, when load
                                balancing is active) after a HTTP status code
                                500&lt;=&lt;i&gt;x&lt;/i&gt;&lt;600 was received.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="adjustHostHeader" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the HTTP "Host" header should be set before the response will be forwarded to its destination.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Set this to &lt;i&gt;false&lt;/i&gt;, if the incoming HTTP "Host" header should not be modified.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="httpSchemaResolver">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.HeaderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="name" type="xsd:string" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="headerFilter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                    The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="exclude">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;excluding&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="include">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;including&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="httpClientConfig">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="proxy" type="com.predic8.membrane.core.config.spring.ProxyconfigurationParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="authentication" type="com.predic8.membrane.core.config.spring.AuthenticationParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="maxRetries" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Determines how often Membrane tries to send a message to a target before it gives up and returns an
                                error message to the client.
                                All tries to all servers count together. For example if you have 2 targets, and a RoundRobin
                                strategy, then the number 5 means it tries, in this order: one, two, one, two, one.
                                NOTE: the word "retries" is used incorrectly throughout this project. The current meaning is "tries".
                                The first attempt, which is semantically not a "re"-try, counts as one already.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="transport">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The transport receives messages from clients and invokes interceptors in the request and response flow.
                The interceptors that are engaged with the transport are global and are invoked for each message flowing
                through the router.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The transport receives messages from clients and invokes interceptors in the request and response flow.
                                    The interceptors that are engaged with the transport are global and are invoked for each message flowing
                                    through the router.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="printStackTrace" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the stack traces of exceptions thrown by interceptors should be returned in the HTTP response.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="reverseDNS" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the remote address should automatically reverse-looked up for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="concurrentConnectionLimitPerIp" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; limits the number of concurrent connections from one ip&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 60&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="coreThreadPoolSize" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Membrane uses a thread pool to allocate threads to incomming clients connections. The core thread pool size is the minimum number of threads that are created in advance to serve client requests.&lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 20&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxThreadPoolSize" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Maximum number of threads to handle incoming connections. (Membrane uses 1 thread per incoming connection.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 300&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;no limit&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="socketTimeout" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Socket timout in ms.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="tcpNoDelay" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to use the "TCP no delay" option. (=A TCP/IP packet should be constructed as soon as any
                                data has been written to the network buffer. With "TCP no delay" set to false, the network hardware
                                waits a short period of time wether the software will write more data. When the packet constructed
                                from the data in the buffer would exceed the MTU in size, the packet is always constructed and sent
                                immediately.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="forceSocketCloseOnHotDeployAfter" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; When proxies.xml is changed and &lt;router hotDeploy="true"&gt;, the Spring Context is automatically refreshed,
                                which restarts the {@link Router} object (=Membrane Service Proxy). Before the context refresh, all open socket connections
                                have to be closed. Exchange objects which are still running might delay this process. Setting forceSocketCloseOnHotDeployAfter
                                to a non-zero number of milliseconds forces connections to be closed after this time.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 30000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="inMemoryStore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="include">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Contains a Java regex for &lt;i&gt;including&lt;/i&gt; message headers.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="index">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                To use this feature just add a serviceProxy containing the index
                element. Of course you can protect the service proxy by using
                SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="jSessionIdExtractor">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;jSessionIdExtractor&lt;/i&gt; extracts the JSESSIONID from a
                message and provides it to the {@link Balancer}.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="javascript">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="jdbcUserDataProvider">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="datasource" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="tableName" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="userColumnName" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="passwordColumnName" type="xsd:string" use="required">
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="jmxExporter">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="jwtSessionManager">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="cookieName" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="timeout" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="domain" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="key">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
                certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
                &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                    &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
                                    certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
                                    &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="private">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                    &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
                                    certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
                                    &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="certificate">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="password" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="keyFile">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="keyGenerator">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
                root CA key.&lt;/p&gt;
                &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                    &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
                                    root CA key.&lt;/p&gt;
                                    &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="key">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                        &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
                                        certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
                                        &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="keystore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="password" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="type" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="provider" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="keyPassword" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="keyAlias" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                The LDAP User Data Provider performs two jobs:
                                &lt;ol&gt;
                                &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
                                &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
                                &lt;/ol&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
                                present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
                                authentication.
                                &lt;/p&gt;
                                &lt;p&gt;
                                Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
                                is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The search returning no node or more than one node is treated as failure.
                                &lt;/p&gt;
                                &lt;p&gt;
                                If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
                                value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
                                equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
                                &lt;i&gt;password&lt;/i&gt; the user provided.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The user attribute keys specified in the mapping are then renamed according to the mapping and used for
                                further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
                                &lt;/p&gt;
                                &lt;p&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
                                search, &lt;i&gt;timeout&lt;/i&gt; can be used.
                                &lt;/p&gt;
                                &lt;p&gt;
                                If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
                                it is set, an additional request is made after the second successful binding to retrieve the node's
                                attributes.
                                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                        <xsd:element ref="ssl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:any namespace="##other" processContents="strict" />
                    </xsd:choice>
                    <xsd:choice minOccurs="0">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                The LDAP User Data Provider performs two jobs:
                                &lt;ol&gt;
                                &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
                                &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
                                &lt;/ol&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
                                present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
                                authentication.
                                &lt;/p&gt;
                                &lt;p&gt;
                                Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
                                is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The search returning no node or more than one node is treated as failure.
                                &lt;/p&gt;
                                &lt;p&gt;
                                If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
                                value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
                                equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
                                &lt;i&gt;password&lt;/i&gt; the user provided.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The user attribute keys specified in the mapping are then renamed according to the mapping and used for
                                further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
                                &lt;/p&gt;
                                &lt;p&gt;
                                &lt;/p&gt;
                                &lt;p&gt;
                                For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
                                search, &lt;i&gt;timeout&lt;/i&gt; can be used.
                                &lt;/p&gt;
                                &lt;p&gt;
                                If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
                                it is set, an additional request is made after the second successful binding to retrieve the node's
                                attributes.
                                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                        <xsd:element name="map" type="com.predic8.membrane.core.config.spring.LdapUserDataProvidermapParser">
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="url" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="base" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="binddn" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="bindpw" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="searchPattern" type="xsd:string" use="required">
                </xsd:attribute>
                <xsd:attribute name="searchScope" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; subtree&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="passwordAttribute" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="timeout" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="connectTimeout" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="readAttributesAsSelf" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="limit">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                aborted and the connection to the backend is simply closed.
                &lt;/p&gt;
                &lt;p&gt;
                To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="maxBodyLength" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The maximal length of a message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 10485760&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="limitedMemoryExchangeStore">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores exchange objects in-memory until a memory threshold is reached. When the threshold is reached and new exchanges arrive then old exchanges will be dropped (starting from oldest ascending) until the exchange can be stored. The LimitedMemoryExchangeStore is the default ExchangeStore Membrane uses.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="maxSize" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="newAlgorithm" type="spel_boolean" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="balancer">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="jSessionIdExtractor">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;jSessionIdExtractor&lt;/i&gt; extracts the JSESSIONID from a
                                        message and provides it to the {@link Balancer}.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlSessionIdExtractor">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extracts a session ID from an XML HTTP request body based on the qualified name of an XML element.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="clusters" type="com.predic8.membrane.core.config.spring.ClustersParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="byThreadStrategy">
                            </xsd:element>
                            <xsd:element ref="roundRobinStrategy">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="nodeOnlineChecker">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Uniquely identifies this Load Balancer, if there is more than one. Used
                                in the web administration interface and lbclient to manage nodes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; balancer1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Default&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="sessionTimeout" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Time in milliseconds after which sessions time out. (If a session
                                extractor is used.) Default is 1 hour, 0 means never.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 600000 &lt;i&gt;(10min)&lt;/i&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 3600000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="log">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                framework. The messages will appear either on the console or in
                a log file depending on the configuration of the
                &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="headerOnly" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set to true only the HTTP header will be logged.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="level" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the log level.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; WARN&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; INFO&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="category" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets the category of the logged message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Membrane&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; com.predic8.membrane.core.interceptor.LogInterceptor&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="login">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                application.
                &lt;/p&gt;
                &lt;p&gt;
                Users firstly have to authenticate themselves against a directory server using a username and password.
                Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                token verification, access to the web application is granted for the user's session. Single Sign On can
                easily be realized using a small source code extension or modification of a web application.
                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                default implementations.)
                &lt;/p&gt;
                &lt;ul&gt;
                &lt;li&gt;
                &lt;p&gt;
                The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                cell phone number, Single Sign On data, etc.).
                &lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                &lt;p&gt;
                The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                session cookie).
                &lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                &lt;p&gt;
                The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                attempts for a specified amount of time.
                &lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                &lt;p&gt;
                The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                secondary channel like text messaging).
                &lt;/p&gt;
                &lt;/li&gt;
                &lt;/ul&gt;
                &lt;p&gt;
                &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                title="login interceptor workflow"/&gt;
                &lt;/p&gt;
                &lt;p&gt;
                (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                possible.)
                &lt;/p&gt;
                &lt;p&gt;
                The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                valid, the workflow is as follows:
                &lt;/p&gt;
                &lt;ul&gt;
                &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                used. Steps 5 and 6.)&lt;/li&gt;
                &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                was directly requested). (Step 8.)&lt;/li&gt;
                &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="customStatementJdbcUserDataProvider">
                            </xsd:element>
                            <xsd:element ref="jdbcUserDataProvider">
                            </xsd:element>
                            <xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The LDAP User Data Provider performs two jobs:
                                        &lt;ol&gt;
                                        &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
                                        &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
                                        &lt;/ol&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
                                        present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
                                        authentication.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
                                        is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The search returning no node or more than one node is treated as failure.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
                                        value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
                                        equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
                                        &lt;i&gt;password&lt;/i&gt; the user provided.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The user attribute keys specified in the mapping are then renamed according to the mapping and used for
                                        further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
                                        search, &lt;i&gt;timeout&lt;/i&gt; can be used.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
                                        it is set, an additional request is made after the second successful binding to retrieve the node's
                                        attributes.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="staticUserDataProvider">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
                                        might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
                                        user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
                                        initialize the token sequence.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
                                        into one.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
                                        user data provider in the order they are specified. After one of the inner user data providers returned
                                        a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
                                        provider could verify the user, the login attempt fails.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The Session Manager identifies users across HTTP requests using a session cookie.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
                                        is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
                                        timeout is 5 minutes.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accountBlocker">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
                                        system) after too many failed login attempts.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
                                        becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
                                        (writing 3600000 means "for 1 hour").
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
                                        (writing 9223372036854775807 means "forever").
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
                                        become blocked. (This is necessary to limit memory usage.)
                                        &lt;/p&gt;
                                        &lt;h3&gt;Discussion&lt;/h3&gt;
                                        &lt;p&gt;
                                        Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
                                        shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
                                        5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
                                        one year is therefore about 56%.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Therefore, a more secure password should be chosen, containing letters, digits and special characters.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="emailTokenProvider" type="com.predic8.membrane.core.config.spring.EmailTokenProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;emailTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
                                        password.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The token is then sent to the user via email. The user's attribute &lt;i&gt;email&lt;/i&gt; is used as the
                                        recipient email address. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
                                        login attempt fails.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The email is sent using the SMTP protocol via the &lt;i&gt;smtpHost&lt;/i&gt;. Optionally, &lt;i&gt;ssl&lt;/i&gt; and &lt;i&gt;smptPort&lt;/i&gt; can
                                        be set to configure the type of connection. Optionally, &lt;i&gt;smtpUser&lt;/i&gt; and &lt;i&gt;smtpPassword&lt;/i&gt; can be used to
                                        use sender authentification.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The email is assembled using &lt;i&gt;sender&lt;/i&gt;, &lt;i&gt;recipient&lt;/i&gt;, &lt;i&gt;subject&lt;/i&gt; and &lt;i&gt;body&lt;/i&gt;. All of these values
                                        may contain properties in the form of &lt;tt&gt;${propertyname}&lt;/tt&gt;.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The properties will be replaced by the corresponding user attributes set by the &lt;i&gt;user data provider&lt;/i&gt;, or &lt;tt&gt;token&lt;/tt&gt;
                                        will be replaced by the numeric token value.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; sending a randomly generated numeric token
                                        to the user via email.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="emptyTokenProvider" type="com.predic8.membrane.core.config.spring.EmptyTokenProviderParser">
                            </xsd:element>
                            <xsd:element name="totpTokenProvider" type="com.predic8.membrane.core.config.spring.TotpTokenProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using the Time-based One-time Password (TOTP) algorithm specified in RFC 6238 to
                                        verify tokens using a pre-shared secret.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;totpTokenProvider&lt;/i&gt; uses the Time-based One-time Password (TOTP) algorithm specified in &lt;a
                                        href="http://tools.ietf.org/html/rfc6238"&gt;RFC 6238&lt;/a&gt; to verify tokens using a pre-shared secret.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The tokens consist of 6 digits.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The user's attribute &lt;i&gt;secret&lt;/i&gt; is used as the pre-shared secret. If this attribute is missing, the
                                        login attempt fails.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Note that the server's system time is taken into account when verifying tokens.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        It is possible, for example, to use the &lt;a href="http://code.google.com/p/google-authenticator"&gt;Google
                                        Authenticator App&lt;/a&gt; to store the pre-shared secret and generate such tokens.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="telekomSMSTokenProvider" type="com.predic8.membrane.core.config.spring.TelekomSMSTokenProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; randomly generates a 6-digit token after the user entered her correct
                                        password.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The token is then sent to the user via text message. The user's attribute &lt;i&gt;sms&lt;/i&gt; is used as the
                                        recipient phone number. If this attribute has not been provided by the &lt;i&gt;user data provider&lt;/i&gt;, the
                                        login attempt fails.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The text message is sent via &lt;a href="http://www.developergarden.com/"&gt;Deutsche Telekom's developer
                                        garden&lt;/a&gt; REST API. To use this API, a registered user account with sufficient balance is necessary and
                                        the &lt;i&gt;Send SMS&lt;/i&gt; API has to be enabled for this account. Membrane Service Proxy must be registered as an
                                        "application" on the developer garden website, and the "Global SMS API" must be enabled both for the user account
                                        as well as the registered application. Once completed, the &lt;i&gt;scope&lt;/i&gt;, &lt;i&gt;clientId&lt;/i&gt; and &lt;i&gt;clientSecret&lt;/i&gt;
                                        settings must be copied from the website into Membrane's proxies.xml configuration file. Membrane uses these three
                                        parameters to identify itself when connecting to the Telekom API Gateway.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        When using a non-standard &lt;i&gt;environment&lt;/i&gt; (see https://www.developergarden.com/apis/documentation/bundle/telekom-api-rest/html/sendsms.html#environmental_infos for more information),
                                        the parameters &lt;i&gt;senderName&lt;/i&gt; and &lt;i&gt;senderAddress&lt;/i&gt; may be used to set the SMS sender address and name.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The token is prepended by &lt;i&gt;prefixText&lt;/i&gt; to generate the text message's text.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If &lt;i&gt;normalizeTelephoneNumber&lt;/i&gt; is set, the user's &lt;i&gt;sms&lt;/i&gt; attribute will be normalized according
                                        to the following rules before using it:
                                        &lt;ul&gt;
                                        &lt;li&gt;'&lt;tt&gt;+&lt;/tt&gt;' is replaced by '&lt;tt&gt;00&lt;/tt&gt;'.&lt;/li&gt;
                                        &lt;li&gt;Any characters within round brackets, '&lt;tt&gt;(&lt;/tt&gt;' and '&lt;tt&gt;)&lt;/tt&gt;', are removed.&lt;/li&gt;
                                        &lt;li&gt;'&lt;tt&gt;-&lt;/tt&gt;' and '&lt;tt&gt;&#160;&lt;/tt&gt;' are removed.&lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;Deutsche Telekom's&lt;/i&gt; REST interface &lt;a
                                        href="http://www.developergarden.com/"&gt;developer garden&lt;/a&gt; to send a randomly generated numeric token
                                        to the user via text message.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="whateverMobileSMSTokenProvider" type="com.predic8.membrane.core.config.spring.WhateverMobileSMSTokenProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;whateverMobileSMSTokenProvider&lt;/i&gt; randomly generates a
                                        6-digit token after the user entered her correct password.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The token is then sent to the user via text message. The user's
                                        attribute &lt;i&gt;sms&lt;/i&gt; is used as the recipient phone number. If
                                        this attribute has not been provided by the &lt;i&gt;user data
                                        provider&lt;/i&gt;, the login attempt fails.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The text message is sent via &lt;a
                                        href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt; REST API.
                                        To use this API, a registered user account with sufficient
                                        balance is necessary. Membrane uses the specified user name and
                                        password to identify itself when connecting to the
                                        WhateverMobile SMS Gateway.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;token provider&lt;/i&gt; using &lt;i&gt;&lt;a
                                        href="https://whatevermobile.com/"&gt;WhateverMobile&lt;/a&gt;'s&lt;/i&gt; REST
                                        interface to send a randomly generated numeric token to the
                                        user's phone via text message.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; location of the login dialog template (a directory containing the &lt;i&gt;index.html&lt;/i&gt; file as well as possibly other resources)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; file:c:/work/login/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="path" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; context path of the login dialog&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /login/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="exposeUserCredentialsToSession" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the user's credentials should be copied over to the session. This means they
                                will stay in memory and will be available to all Membrane components.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="message" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Set the message displayed during redirect.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="regex" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Java Regular expression&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /bank/.*&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="soapAction" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Value of the soapAction header field.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="soapURI" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Endpoint address of the SOAP service.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /axis2/$1&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="requestXSLT" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Transformation that will be applied to the request.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; blz-request.xsl&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="responseXSLT" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Transformation that will be applied to the response.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; shop-request.xsl&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="membrane">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="registration">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="httpClientConfiguration" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="clientId" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="clientSecret" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="scope" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="subject" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="src" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="claims" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; claims that are requested for the userinfo endpoint&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="claimsIdt" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; claims that are requested for the id_token&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="memoryExchangeStore">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Stores all exchanges in-memory. The Java heap will overflow if this store is used to store too many
                Exchanges. Use for Membrane Monitor only.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="analyser">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="methodOverride">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.NodeParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="host" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The node's host.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; server3&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="port" type="spel_number" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The node's port.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="nodeOnlineChecker">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="retryTimeInSeconds" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the time in seconds until offline nodes are checked again. -1 to disable&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="nodeCounterLimit5XX" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the number of times a node has to fail with a 5XX statuscode until it is taken down&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 10&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="oauth2authserver">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1">
                            <xsd:element ref="customStatementJdbcUserDataProvider">
                            </xsd:element>
                            <xsd:element ref="jdbcUserDataProvider">
                            </xsd:element>
                            <xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The LDAP User Data Provider performs two jobs:
                                        &lt;ol&gt;
                                        &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
                                        &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
                                        &lt;/ol&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
                                        present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
                                        authentication.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
                                        is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The search returning no node or more than one node is treated as failure.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
                                        value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
                                        equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
                                        &lt;i&gt;password&lt;/i&gt; the user provided.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The user attribute keys specified in the mapping are then renamed according to the mapping and used for
                                        further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
                                        search, &lt;i&gt;timeout&lt;/i&gt; can be used.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
                                        it is set, an additional request is made after the second successful binding to retrieve the node's
                                        attributes.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="staticUserDataProvider">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
                                        might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
                                        user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
                                        initialize the token sequence.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
                                        into one.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
                                        user data provider in the order they are specified. After one of the inner user data providers returned
                                        a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
                                        provider could verify the user, the login attempt fails.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The Session Manager identifies users across HTTP requests using a session cookie.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
                                        is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
                                        timeout is 5 minutes.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="accountBlocker">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Keeps track of blocked user accounts (accounts become blocked after too many failed logins).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The Account Blocker prevents password and token guessing attempts: It blocks a user (or the whole
                                        system) after too many failed login attempts.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        When a user entered a wrong password or wrong token more than &lt;i&gt;afterFailedLogins&lt;/i&gt; times, this user
                                        becomes blocked: He will be prevented from logging in again within the next &lt;i&gt;blockFor&lt;/i&gt; milliseconds
                                        (writing 3600000 means "for 1 hour").
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The failed login attempts have to occur within the last &lt;i&gt;afterFailedLoginsWithin&lt;/i&gt; milliseconds
                                        (writing 9223372036854775807 means "forever").
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If more than &lt;i&gt;blockWholeSystemAfter&lt;/i&gt; users become blocked at a time, the &lt;i&gt;all&lt;/i&gt; users will
                                        become blocked. (This is necessary to limit memory usage.)
                                        &lt;/p&gt;
                                        &lt;h3&gt;Discussion&lt;/h3&gt;
                                        &lt;p&gt;
                                        Say, for example, a scripted dictionary attack tries to guess a user's password. Using the configuration
                                        shown above, which is the default configuration if no &lt;i&gt;accountBlocker&lt;/i&gt; is declared, this results in
                                        5 guesses per 3600000 milliseconds; or equivalently 42720 guesses per year.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The probability of hitting a uniformly at random chosen word of the standard German vocabulary within
                                        one year is therefore about 56%.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Therefore, a more secure password should be chosen, containing letters, digits and special characters.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="1">
                            <xsd:element ref="staticClientList">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="bearerToken">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="1">
                            <xsd:element ref="claims">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="path" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="message" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="exposeUserCredentialsToSession" type="spel_boolean" >
                    </xsd:attribute>
                    <xsd:attribute name="issuer" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="consentFile" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="oauth2Resource">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                authorization server as response.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                    authorization server as response.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="github" type="com.predic8.membrane.core.config.spring.GithubParser">
                            </xsd:element>
                            <xsd:element name="google" type="com.predic8.membrane.core.config.spring.GoogleParser">
                            </xsd:element>
                            <xsd:element ref="membrane">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                    authorization server as response.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="sessionManager" type="com.predic8.membrane.core.config.spring.SessionManagerParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The Session Manager identifies users across HTTP requests using a session cookie.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The name of the session cookie can be specified using the &lt;i&gt;cookieName&lt;/i&gt; attribute. The default name
                                        is "&lt;tt&gt;SESSIONID&lt;/tt&gt;".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The session timeout can be specified in milliseconds using the &lt;i&gt;timeout&lt;/i&gt; attribute. The default
                                        timeout is 5 minutes.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="loginLocation" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; location of the login dialog template (a directory containing the &lt;i&gt;index.html&lt;/i&gt; file as well as possibly other resources).
                                Required for older browsers to work.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; file:c:/work/login/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="loginPath" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; context path of the login dialog&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; /login/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="publicURL" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="revalidateTokenAfter" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; time in seconds until a oauth2 access token is revalidatet with authorization server. This is disabled for values &lt; 0&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; -1&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="tokenValidator">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="endpoint" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the endpoint that validates the access token&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.PathParser">
        <xsd:complexContent mixed="true">
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="isRegExp" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set to true the content will be evaluated as a &lt;a href="http://docs.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html"&gt;Java Regular Expression&lt;/a&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="private">
        <xsd:complexType>
            <xsd:complexContent mixed="true">
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="prometheus">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ProxyconfigurationParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0">
                        <xsd:element ref="ssl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
                <xsd:attribute name="host" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="port" type="spel_number" >
                </xsd:attribute>
                <xsd:attribute name="password" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="username" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="authentication" type="spel_boolean" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="proxy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts onbehalf of the client.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts onbehalf of the client.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts onbehalf of the client.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockRequest" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockResponse" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="rest2Soap">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="mapping" type="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="rateLimiter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="requestLimit" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; number of requests&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="requestLimitDuration" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Duration after the limit is reset in PTxS where x is the
                                time in seconds&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; PT3600S&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="regExReplacer">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="regex" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Regex to match against the body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Hallo&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="replace" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; String used to replace matched parts.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Hello&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="target" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether the replacement should affect the message &lt;tt&gt;body&lt;/tt&gt; or the &lt;tt&gt;header&lt;/tt&gt; values.
                                Possible values are body and header.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; header&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; body&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="accountRegistration">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.RequestParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                        <xsd:element ref="accessControl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                    requested resource.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="adminConsole">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="apiKeyChecker">
                        </xsd:element>
                        <xsd:element ref="apiManagement">
                        </xsd:element>
                        <xsd:element ref="authHead2Body">
                        </xsd:element>
                        <xsd:element ref="basicAuthentication">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="cache">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Don't use, this does NOT implement valid HTTP caching.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                    the Docker Registry for offline use.
                                    The cache does not revalidate any responses, so machines querying the cache for Debian
                                    package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                    This is - simply put - the only use case, where using this class makes any sense.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="clamav">
                        </xsd:element>
                        <xsd:element ref="clusterNotification">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="if">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The "if" interceptor supports conditional execution of a group of executors.
                                    &lt;/p&gt;

                                    &lt;p&gt;
                                    Note that this is a draft implementation only: Design decissions are still pending.
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                    &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                    &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="counter">
                        </xsd:element>
                        <xsd:element ref="dispatching">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                    element to the list of destinations of the exchange object. It
                                    must be placed into the transport to make Service Proxies Work
                                    properly. It has to be placed after the ruleMatching
                                    interceptor. The ruleMatching interceptor looks up a service
                                    proxy for an incoming request and places it into the exchange
                                    object. The dispatching interceptor needs the service proxy to
                                    get information about the target.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="exchangeStore">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                    might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="formValidation">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="groovy">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="groovyTemplate">
                        </xsd:element>
                        <xsd:element ref="http2xml">
                        </xsd:element>
                        <xsd:element ref="httpClient">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                    Server using the HTTP protocol. Usually it will be globally used
                                    inside the transport. However, it is also possible to use it
                                    inside a proxy to give the proxy an individual configuration for
                                    its outgoing HTTP connection that is different from the global
                                    configuration in the transport.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="headerFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                    The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="index">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                    To use this feature just add a serviceProxy containing the index
                                    element. Of course you can protect the service proxy by using
                                    SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="javascript">
                        </xsd:element>
                        <xsd:element ref="limit">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                    the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                    aborted and the connection to the backend is simply closed.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                    &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="balancer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="log">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                    framework. The messages will appear either on the console or in
                                    a log file depending on the configuration of the
                                    &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="login">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="analyser">
                        </xsd:element>
                        <xsd:element ref="methodOverride">
                        </xsd:element>
                        <xsd:element ref="oauth2authserver">
                        </xsd:element>
                        <xsd:element ref="oauth2Resource">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                    authorization server as response.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="tokenValidator">
                        </xsd:element>
                        <xsd:element ref="prometheus">
                        </xsd:element>
                        <xsd:element ref="rest2Soap">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="rateLimiter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="regExReplacer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="accountRegistration">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                    &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                    &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="reverseProxying">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                    as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                    hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="rewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Rewrites the path of incoming requests based on a mapping or redirects requests.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="ruleMatching">
                        </xsd:element>
                        <xsd:element ref="soap2Rest">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="soapStackTraceFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                    advised to test its functionality in combination with your SOAP service provider before deploying it in
                                    production.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="spdy">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="stompClient">
                        </xsd:element>
                        <xsd:element ref="soapOperationExtractor">
                        </xsd:element>
                        <xsd:element ref="interceptor">
                        </xsd:element>
                        <xsd:element ref="statisticsCSV">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                    file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="statisticsJDBC">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                    database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="statisticsProvider">
                        </xsd:element>
                        <xsd:element ref="swaggerApiKeyRequirer">
                        </xsd:element>
                        <xsd:element ref="swaggerRewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="tcp">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="testService">
                        </xsd:element>
                        <xsd:element ref="throttle">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The throttle feature can slow down traffic to thwart denial of service attacks.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="urlNormalizer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Replaces "/./" in the request URI's path by "/".
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                    links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                    root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                    "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                    new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                    not match.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="userFeature">
                            <xsd:annotation>
                                <xsd:documentation></xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="validator">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="wadlRewriter">
                        </xsd:element>
                        <xsd:element ref="wsdlRewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="wsdlPublisher">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                    backend service does not already do so.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="webServer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                    "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                    HTTP response with the contents of a file, or a "404 Not Found." error.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="webServiceExplorer">
                        </xsd:element>
                        <xsd:element ref="webSocket">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="xmlContentFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                    using an XPath expression.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                    match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                    to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                    lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                    namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                    &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                    the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                    constructed.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                    XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                    modified reconstituted message.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="xmlProtection">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                    attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="switch">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="transform">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                    transformation the body content is replaced with the result of the transformation.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:any namespace="##other" processContents="strict" />
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="resolverMap">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation></xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="etcdResolver">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ResponseParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="0" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                        <xsd:element ref="accessControl">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                    requested resource.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="adminConsole">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="apiKeyChecker">
                        </xsd:element>
                        <xsd:element ref="apiManagement">
                        </xsd:element>
                        <xsd:element ref="authHead2Body">
                        </xsd:element>
                        <xsd:element ref="basicAuthentication">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="cache">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Don't use, this does NOT implement valid HTTP caching.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                    the Docker Registry for offline use.
                                    The cache does not revalidate any responses, so machines querying the cache for Debian
                                    package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                    This is - simply put - the only use case, where using this class makes any sense.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="clamav">
                        </xsd:element>
                        <xsd:element ref="clusterNotification">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="if">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The "if" interceptor supports conditional execution of a group of executors.
                                    &lt;/p&gt;

                                    &lt;p&gt;
                                    Note that this is a draft implementation only: Design decissions are still pending.
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                    &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                    &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="counter">
                        </xsd:element>
                        <xsd:element ref="dispatching">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                    element to the list of destinations of the exchange object. It
                                    must be placed into the transport to make Service Proxies Work
                                    properly. It has to be placed after the ruleMatching
                                    interceptor. The ruleMatching interceptor looks up a service
                                    proxy for an incoming request and places it into the exchange
                                    object. The dispatching interceptor needs the service proxy to
                                    get information about the target.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="exchangeStore">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                    might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="formValidation">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="groovy">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="groovyTemplate">
                        </xsd:element>
                        <xsd:element ref="http2xml">
                        </xsd:element>
                        <xsd:element ref="httpClient">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                    Server using the HTTP protocol. Usually it will be globally used
                                    inside the transport. However, it is also possible to use it
                                    inside a proxy to give the proxy an individual configuration for
                                    its outgoing HTTP connection that is different from the global
                                    configuration in the transport.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="headerFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                    The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="index">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                    To use this feature just add a serviceProxy containing the index
                                    element. Of course you can protect the service proxy by using
                                    SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="javascript">
                        </xsd:element>
                        <xsd:element ref="limit">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                    the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                    aborted and the connection to the backend is simply closed.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                    &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="balancer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="log">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                    framework. The messages will appear either on the console or in
                                    a log file depending on the configuration of the
                                    &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="login">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                    application.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Users firstly have to authenticate themselves against a directory server using a username and password.
                                    Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                    token verification, access to the web application is granted for the user's session. Single Sign On can
                                    easily be realized using a small source code extension or modification of a web application.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                    each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                    default implementations.)
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                    cell phone number, Single Sign On data, etc.).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                    session cookie).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                    attempts for a specified amount of time.
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;li&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                    secondary channel like text messaging).
                                    &lt;/p&gt;
                                    &lt;/li&gt;
                                    &lt;/ul&gt;
                                    &lt;p&gt;
                                    &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                    title="login interceptor workflow"/&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                    possible.)
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                    valid, the workflow is as follows:
                                    &lt;/p&gt;
                                    &lt;ul&gt;
                                    &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                    &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                    &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                    used. Steps 5 and 6.)&lt;/li&gt;
                                    &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                    &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                    was directly requested). (Step 8.)&lt;/li&gt;
                                    &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="analyser">
                        </xsd:element>
                        <xsd:element ref="methodOverride">
                        </xsd:element>
                        <xsd:element ref="oauth2authserver">
                        </xsd:element>
                        <xsd:element ref="oauth2Resource">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                    authorization server as response.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="tokenValidator">
                        </xsd:element>
                        <xsd:element ref="prometheus">
                        </xsd:element>
                        <xsd:element ref="rest2Soap">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="rateLimiter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="regExReplacer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="accountRegistration">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                    &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                    &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="reverseProxying">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                    as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                    hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="rewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Rewrites the path of incoming requests based on a mapping or redirects requests.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="ruleMatching">
                        </xsd:element>
                        <xsd:element ref="soap2Rest">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="soapStackTraceFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                    advised to test its functionality in combination with your SOAP service provider before deploying it in
                                    production.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="spdy">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="stompClient">
                        </xsd:element>
                        <xsd:element ref="soapOperationExtractor">
                        </xsd:element>
                        <xsd:element ref="interceptor">
                        </xsd:element>
                        <xsd:element ref="statisticsCSV">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                    file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="statisticsJDBC">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                    database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="statisticsProvider">
                        </xsd:element>
                        <xsd:element ref="swaggerApiKeyRequirer">
                        </xsd:element>
                        <xsd:element ref="swaggerRewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="tcp">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="testService">
                        </xsd:element>
                        <xsd:element ref="throttle">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The throttle feature can slow down traffic to thwart denial of service attacks.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="urlNormalizer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Replaces "/./" in the request URI's path by "/".
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                    links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                    root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                    "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                    new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                    not match.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="userFeature">
                            <xsd:annotation>
                                <xsd:documentation></xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="validator">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="wadlRewriter">
                        </xsd:element>
                        <xsd:element ref="wsdlRewriter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="wsdlPublisher">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                    backend service does not already do so.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="webServer">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                    "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                    HTTP response with the contents of a file, or a "404 Not Found." error.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="webServiceExplorer">
                        </xsd:element>
                        <xsd:element ref="webSocket">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="xmlContentFilter">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                    using an XPath expression.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                    match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                    to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                    lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                    namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                    &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                    the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                    constructed.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                    XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                    modified reconstituted message.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="xmlProtection">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                    attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="switch">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="transform">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                    transformation the body content is replaced with the result of the transformation.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:any namespace="##other" processContents="strict" />
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="reverseProxying">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="rewriter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Rewrites the path of incoming requests based on a mapping or redirects requests.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Rewrites the path of incoming requests based on a mapping or redirects requests.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="mapping" type="com.predic8.membrane.core.config.spring.Rest2SoapmappingParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="roundRobinStrategy">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="router">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Membrane Service Proxy&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Membrane Service Proxy's main object.
                &lt;/p&gt;
                &lt;p&gt;
                The router is a Spring Lifecycle object: It is automatically started and stopped according to the
                Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
                app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
                &lt;/p&gt;
                &lt;p&gt;
                In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
                configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
                that, during the Spring Context restart, the router object itself along with almost all other Membrane
                objects (interceptors, etc.) will be recreated.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Membrane Service Proxy&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Membrane Service Proxy's main object.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The router is a Spring Lifecycle object: It is automatically started and stopped according to the
                                    Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
                                    app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
                                    configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
                                    that, during the Spring Context restart, the router object itself along with almost all other Membrane
                                    objects (interceptors, etc.) will be recreated.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="uriFactory">
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Membrane Service Proxy&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Membrane Service Proxy's main object.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The router is a Spring Lifecycle object: It is automatically started and stopped according to the
                                    Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
                                    app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
                                    configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
                                    that, during the Spring Context restart, the router object itself along with almost all other Membrane
                                    objects (interceptors, etc.) will be recreated.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="httpClientConfig">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Membrane Service Proxy&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Membrane Service Proxy's main object.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The router is a Spring Lifecycle object: It is automatically started and stopped according to the
                                    Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
                                    app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
                                    configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
                                    that, during the Spring Context restart, the router object itself along with almost all other Membrane
                                    objects (interceptors, etc.) will be recreated.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="transport">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transport receives messages from clients and invokes interceptors in the request and response flow.
                                        The interceptors that are engaged with the transport are global and are invoked for each message flowing
                                        through the router.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 1. Membrane Service Proxy&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    Membrane Service Proxy's main object.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The router is a Spring Lifecycle object: It is automatically started and stopped according to the
                                    Lifecycle of the Spring Context containing it. In Membrane's standard setup (standalone or in a J2EE web
                                    app), Membrane itself controls the creation of the Spring Context and its Lifecycle.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    In this case, the router is &lt;i&gt;hot deployable&lt;/i&gt;: It can monitor &lt;i&gt;proxies.xml&lt;/i&gt;, the Spring
                                    configuration file, for changes and reinitialize the Spring Context, when a change is detected. Note
                                    that, during the Spring Context restart, the router object itself along with almost all other Membrane
                                    objects (interceptors, etc.) will be recreated.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="proxy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Clients can send HTTP requests to a proxy that forward the request to a Web server. It acts onbehalf of the client.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapProxy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        A SOAP proxy can be deployed on front of a SOAP Web Service. It conceals the server and offers the same
                                        interface as the target server to its clients.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL referenced by the &lt;i&gt;wsdl&lt;/i&gt; attribute is not available at startup, the &lt;soapProxy&gt;
                                        will become inactive. Through the admin console, reinitialization attempts can be triggered and, by
                                        default, the {@link Router} also periodically triggers such attempts.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="sslProxy">
                            </xsd:element>
                            <xsd:element ref="stompProxy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="serviceProxy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                                        the server and offers the same interface as the target server to its clients.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="swaggerProxy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        A service proxy that handles Swagger REST API calls.
                                        It includes a SwaggerRewriterInterceptor ex factory.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="exchangeStore" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring Bean ID of an {@link ExchangeStore}. The exchange store will be used by this router's
                                components ({@link AdminConsoleInterceptor}, {@link ExchangeStoreInterceptor}, etc.) by default, if
                                no other exchange store is explicitly set to be used by them.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; create a {@link LimitedMemoryExchangeStore} limited to the size of 1 MB.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="hotDeploy" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Whether changes to the router's configuration file should automatically trigger a restart.
                                &lt;/p&gt;
                                &lt;p&gt;
                                Monitoring the router's configuration file &lt;i&gt;proxies.xml&lt;/i&gt; is only possible, if the router
                                is created by a Spring Application Context which supports monitoring.
                                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="retryInitInterval" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; number of milliseconds after which reinitialization of &lt;soapProxy&gt;s should be attempted periodically&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 5 minutes&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="retryInit" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Whether the router should continue startup, if initialization of a rule (proxy, serviceProxy or soapProxy) failed
                                (for example, when a WSDL a component depends on could not be downloaded).&lt;/p&gt;
                                &lt;p&gt;If false, the router will exit with code -1 just after startup, when the initialization of a rule failed.&lt;/p&gt;
                                &lt;p&gt;If true, the router will continue startup, and all rules which could not be initialized will be &lt;i&gt;inactive&lt;/i&gt; (=not
                                {@link Rule#isActive()}).&lt;/p&gt;
                                &lt;h3&gt;Inactive rules&lt;/h3&gt;
                                &lt;p&gt;Inactive rules will simply be ignored for routing decissions for incoming requests.
                                This means that requests for inactive rules might be routed using different routes or result in a "400 Bad Request"
                                when no active route could be matched to the request.&lt;/p&gt;
                                &lt;p&gt;Once rules become active due to reinitialization, they are considered in future routing decissions.&lt;/p&gt;
                                &lt;h3&gt;Reinitialization&lt;/h3&gt;
                                &lt;p&gt;Inactive rules may be &lt;i&gt;reinitialized&lt;/i&gt; and, if reinitialization succeeds, become active.&lt;/p&gt;
                                &lt;p&gt;By default, reinitialization is attempted at regular intervals using a timer (see {@link #setRetryInitInterval(int)}).&lt;/p&gt;
                                &lt;p&gt;Additionally, using the {@link AdminConsoleInterceptor}, an admin may trigger reinitialization of inactive rules at any time.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="jmx" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="ruleMatching">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="xForwardedForEnabled" type="spel_boolean" >
                    </xsd:attribute>
                    <xsd:attribute name="maxXForwardedForHeaders" type="spel_number" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="soap2Rest">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="requestXSLT" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="responseXSLT" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="soapProxy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                A SOAP proxy can be deployed on front of a SOAP Web Service. It conceals the server and offers the same
                interface as the target server to its clients.
                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL referenced by the &lt;i&gt;wsdl&lt;/i&gt; attribute is not available at startup, the &lt;soapProxy&gt;
                will become inactive. Through the admin console, reinitialization attempts can be triggered and, by
                default, the {@link Router} also periodically triggers such attempts.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A SOAP proxy can be deployed on front of a SOAP Web Service. It conceals the server and offers the same
                                    interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL referenced by the &lt;i&gt;wsdl&lt;/i&gt; attribute is not available at startup, the &lt;soapProxy&gt;
                                    will become inactive. Through the admin console, reinitialization attempts can be triggered and, by
                                    default, the {@link Router} also periodically triggers such attempts.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The value of the content will be taken to match the path.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
                                        &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
                                        attribute must not be present.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A SOAP proxy can be deployed on front of a SOAP Web Service. It conceals the server and offers the same
                                    interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL referenced by the &lt;i&gt;wsdl&lt;/i&gt; attribute is not available at startup, the &lt;soapProxy&gt;
                                    will become inactive. Through the admin console, reinitialization attempts can be triggered and, by
                                    default, the {@link Router} also periodically triggers such attempts.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A SOAP proxy can be deployed on front of a SOAP Web Service. It conceals the server and offers the same
                                    interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; If the WSDL referenced by the &lt;i&gt;wsdl&lt;/i&gt; attribute is not available at startup, the &lt;soapProxy&gt;
                                    will become inactive. Through the admin console, reinitialization attempts can be triggered and, by
                                    default, the {@link Router} also periodically triggers such attempts.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockRequest" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockResponse" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
                                header of incoming HTTP requests matches one of the hostnames.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
                                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="wsdl" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL of the SOAP service.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://predic8.de/my.wsdl &lt;i&gt;or&lt;/i&gt; file:my.wsdl&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="portName" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="wsdlHttpClientConfig" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="soapStackTraceFilter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                &lt;/p&gt;
                &lt;p&gt;
                The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                advised to test its functionality in combination with your SOAP service provider before deploying it in
                production.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="spdy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                After the upgrade, the connection's data packets are simply forwarded
                and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="ssl">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="keystore">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="key">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                        &lt;p&gt;Allows to insert a PEM block containing the key (as well as one or more blocks for the
                                        certificate(s)) directly into the proxies.xml file.&lt;/p&gt;
                                        &lt;p&gt;This is an alternative for {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="keyGenerator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                        &lt;p&gt;Allows to dynamically generate keys/certificates for arbitrary domain names on the fly, signed by a specified
                                        root CA key.&lt;/p&gt;
                                        &lt;p&gt;This is an alternative for {@link Key} and {@link KeyStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="truststore">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="trust">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                        &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
                                        file.&lt;/p&gt;
                                        &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="algorithm" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/KeyManagerFactory.html#getDefaultAlgorithm%28%29"&gt;getDefaultAlgorithm()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; SunX509&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; java default&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="protocol" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLContext.html#getInstance%28java.lang.String%29"&gt;SSLContext.getInstance()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TLS&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="protocols" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLSocket.html#setEnabledProtocols%28java.lang.String[]%29"&gt;SSLSocket.setEnabledProtocols()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; TLS*&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ciphers" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Space separated list of ciphers to allow. &lt;a href="http://docs.oracle.com/javase/6/docs/api/javax/net/ssl/SSLSocketFactory.html#getSupportedCipherSuites%28%29"&gt;getSupportedCipherSuites()&lt;/a&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; TLS_ECDH_anon_WITH_RC4_128_SHA&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; all system default ciphers&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="clientAuth" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Either not set (=no), or &lt;tt&gt;want&lt;/tt&gt; or &lt;tt&gt;need&lt;/tt&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; &lt;tt&gt;need&lt;/tt&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ignoreTimestampCheckFailure" type="spel_boolean" >
                    </xsd:attribute>
                    <xsd:attribute name="endpointIdentificationAlgorithm" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; See &lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/net/ssl/SSLParameters.html#setEndpointIdentificationAlgorithm%28java.lang.String%29"&gt;setEndpointIdentificationAlgorithm()&lt;/a&gt;.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; HTTPS&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="serverName" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Setting the serverName tells Java to use the SNI (http://www.rfc-base.org/txt/rfc-3546.txt) on outbound
                                TLS connections to indicate to the TLS server, which hostname the client wants to connect to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; same as target hostname.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="showSSLExceptions" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Tells Membrane to show SSL exceptions in its log&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="sslProxy">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="1">
                            <xsd:element name="target" type="com.predic8.membrane.core.config.spring.SslProxytargetParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="port" type="spel_number" >
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="stompClient">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="connection" type="com.predic8.membrane.core.config.spring.ConnectionParser">
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port to connect to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 61613&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The host (name or IP) to connect to.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="stompProxy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Proxies incoming STOMP CONNECT requests. Use a &lt;stompClient&gt; to forward these requests so some other machine.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockRequest" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockResponse" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.ClaimsscopeParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="claims" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the properties seperated by spaces&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="serviceProxy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                the server and offers the same interface as the target server to its clients.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                                    the server and offers the same interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The value of the content will be taken to match the path.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
                                        &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
                                        attribute must not be present.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                                    the server and offers the same interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                                    the server and offers the same interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 2. Proxies&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy can be deployed on front of a Web server, Web Service or a REST resource. It conceals
                                    the server and offers the same interface as the target server to its clients.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="target" type="com.predic8.membrane.core.config.spring.SslProxytargetParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockRequest" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockResponse" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
                                header of incoming HTTP requests matches one of the hostnames.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
                                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="method" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set, Membrane will only consider this rule, if the method (GET, PUT, POST, DELETE, etc.)
                                header of incoming HTTP requests matches. The asterisk '*' matches any method.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; GET&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; *&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="externalHostname" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.SessionManagerParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="cookieName" type="xsd:string" >
                </xsd:attribute>
                <xsd:attribute name="timeout" type="spel_number" >
                </xsd:attribute>
                <xsd:attribute name="domain" type="xsd:string" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="simpleApiConfig">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="url" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; the url to the configuration file&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; api.yaml&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="soapOperationExtractor">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="interceptor">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="refid" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring bean id of the referenced interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; myInterceptor&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="staticClientList">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:element name="client" type="com.predic8.membrane.core.config.spring.StaticClientListclientParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="staticUserDataProvider">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
                &lt;/p&gt;
                &lt;p&gt;
                each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
                &lt;/p&gt;
                &lt;p&gt;
                arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
                might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
                user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
                initialize the token sequence.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
                                    might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
                                    user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
                                    initialize the token sequence.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="user" type="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="statisticsCSV">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="file" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Locations of csv file to write out logs.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; stat.csv&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="statisticsJDBC">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                database (one row per exchange).&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="dataSource" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The spring bean ID of a data source bean.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="postMethodOnly" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="soapOnly" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="statisticsProvider">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="dataSourceBeanId" type="xsd:string" use="required">
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="swaggerApiKeyRequirer">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:element name="header" type="com.predic8.membrane.core.config.spring.HeaderParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="swaggerProxy">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                A service proxy that handles Swagger REST API calls.
                It includes a SwaggerRewriterInterceptor ex factory.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy that handles Swagger REST API calls.
                                    It includes a SwaggerRewriterInterceptor ex factory.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="path" type="com.predic8.membrane.core.config.spring.PathParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The value of the content will be taken to match the path.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;isRegExp="true"&lt;/tt&gt;, the whole path has to match the given regular expression. If
                                        &lt;tt&gt;isRegExp="false"&lt;/tt&gt;, the path has to start with the given string.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        If &lt;tt&gt;&lt;path /&gt;&lt;/tt&gt; is a child element of a &lt;tt&gt;&lt;soapProxy /&gt;&lt;/tt&gt;, the &lt;tt&gt;isRegExp&lt;/tt&gt;
                                        attribute must not be present.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy that handles Swagger REST API calls.
                                    It includes a SwaggerRewriterInterceptor ex factory.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="ssl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;Configures inbound or outbound SSL connections.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy that handles Swagger REST API calls.
                                    It includes a SwaggerRewriterInterceptor ex factory.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:any namespace="##other" processContents="strict" />
                        </xsd:choice>
                        <xsd:choice minOccurs="0">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    A service proxy that handles Swagger REST API calls.
                                    It includes a SwaggerRewriterInterceptor ex factory.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="target" type="com.predic8.membrane.core.config.spring.SslProxytargetParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="name" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The name as shown in the Admin Console.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; By default, a name will be automatically generated from the target host, port, etc.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockRequest" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="blockResponse" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;legacy attribute&lt;/i&gt; for usage by Membrane Monitor&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port Membrane listens on for incoming connections.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 8080&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 80&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="ip" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If present, binds the port only on the specified IP. Useful for hosts with multiple IP addresses.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 127.0.0.1&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;A space separated list of hostnames. If set, Membrane will only consider this rule, if the "Host"
                                header of incoming HTTP requests matches one of the hostnames.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The asterisk '*' can be used for basic globbing (to match any number, including zero, characters).
                                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; predic8.de *.predic8.de&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; &lt;i&gt;not set&lt;/i&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="method" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If set, Membrane will only consider this rule, if the method (GET, PUT, POST, DELETE, etc.)
                                header of incoming HTTP requests matches. The asterisk '*' matches any method.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; GET&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; *&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="externalHostname" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="url" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The Swagger URL. Preferably ends with 'swagger.json'.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://petstore.swagger.io/v2/swagger.json&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="allowUI" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to allow Swagger UI forwarding&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="swaggerRewriter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="rewriteUI" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether a Swagger-UI should also be rewritten.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="swaggerJson" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Swagger specification filename. The default is 'swagger.json', which is also recommended.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; swagger.json&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="tcp">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                After the upgrade, the connection's data packets are simply forwarded
                and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.TotpTokenProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.SslProxytargetParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="port" type="spel_number" >
                </xsd:attribute>
                <xsd:attribute name="host" type="xsd:string" >
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.TelekomSMSTokenProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="prefixText" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A string that will be prepended to the token when creating the text message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="simulate" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Don't send any text messages, only write tokens to the log.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="scope" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;scope&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="clientId" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;clientId&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="clientSecret" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;clientSecret&lt;/i&gt; assigned to you by developergarden.com .&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="senderName" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender name of the text messages. May only be set, if you are a member of the &lt;i&gt;premium&lt;/i&gt; program on developergarded.com .&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="senderAddress" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender address (telephone number) of the text messages. May only be set, if you are a member of the &lt;i&gt;premium&lt;/i&gt; program on developergarded.com .&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="environment" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;environment&lt;/i&gt; (program name) you are paying for on developergarden.com .&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; premium&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; budget&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="testService">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="throttle">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The throttle feature can slow down traffic to thwart denial of service attacks.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="delay" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If non-zero, delays requests by specified number of milliseconds.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxThreads" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If non-zero, newly incoming request are aborted if the number of running requests has reached this limit.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 5&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="busyDelay" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If a newly incoming request exceeds maxThreads, the interceptor waits the specified number in
                                milliseconds and retries once before aborting the request.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 3000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 0&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="trust">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
                file.&lt;/p&gt;
                &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Experimental.
                                    &lt;p&gt;Allows to insert one or more PEM blocks containing the certificates to be trusted directly into the proxies.xml
                                    file.&lt;/p&gt;
                                    &lt;p&gt;This is an alternative for {@link TrustStore}.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="certificate">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="algorithm" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="checkRevocation" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="truststore">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="location" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="password" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="type" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="provider" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="algorithm" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="checkRevocation" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="uriFactory">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="allowIllegalCharacters" type="spel_boolean" >
                    </xsd:attribute>
                    <xsd:attribute name="autoEscapeBackslashes" type="spel_boolean" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="urlNormalizer">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Replaces "/./" in the request URI's path by "/".
                &lt;/p&gt;
                &lt;p&gt;
                Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                not match.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                    <xsd:choice minOccurs="1" maxOccurs="unbounded">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
                                into one.
                                &lt;/p&gt;
                                &lt;p&gt;
                                The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
                                user data provider in the order they are specified. After one of the inner user data providers returned
                                a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
                                provider could verify the user, the login attempt fails.
                                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                        <xsd:element ref="customStatementJdbcUserDataProvider">
                        </xsd:element>
                        <xsd:element ref="jdbcUserDataProvider">
                        </xsd:element>
                        <xsd:element name="ldapUserDataProvider" type="com.predic8.membrane.core.config.spring.LdapUserDataProviderParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; querying an LDAP server to authorize users and retrieve attributes.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The LDAP User Data Provider performs two jobs:
                                    &lt;ol&gt;
                                    &lt;li&gt;Authentication of a &lt;i&gt;username&lt;/i&gt; and &lt;i&gt;password&lt;/i&gt;.&lt;/li&gt;
                                    &lt;li&gt;Retrieval of user attributes.&lt;/li&gt;
                                    &lt;/ol&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    To achieve this, it first binds to &lt;i&gt;base&lt;/i&gt; on the LDAP server &lt;i&gt;url&lt;/i&gt;. If &lt;i&gt;binddn&lt;/i&gt; is not
                                    present, it binds to the LDAP server anonymously, elsewise &lt;i&gt;binddn&lt;/i&gt; and &lt;i&gt;bindpw&lt;/i&gt; are used for
                                    authentication.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    Next, a search &lt;i&gt;searchPattern&lt;/i&gt; with scope &lt;i&gt;searchScope&lt;/i&gt; is executed where "&lt;tt&gt;%LOGIN%&lt;/tt&gt;"
                                    is replaced by the escaped version of the &lt;i&gt;username&lt;/i&gt;.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The search returning no node or more than one node is treated as failure.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    If &lt;i&gt;passwordAttribute&lt;/i&gt; is set, and the node has an attribute with this name and this attribute's
                                    value starts with "&lt;tt&gt;{x-plain}&lt;/tt&gt;", the password is checked against the rest of the value for
                                    equality. If &lt;i&gt;passwordAttribute&lt;/i&gt; is not set, a second binding is attempted on the node using the
                                    &lt;i&gt;password&lt;/i&gt; the user provided.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The user attribute keys specified in the mapping are then renamed according to the mapping and used for
                                    further processing (see the other modules of the &lt;i&gt;login&lt;/i&gt; interceptor).
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    For the initial binding, &lt;i&gt;connectTimeout&lt;/i&gt; can be used to specify a timeout in milliseconds. For the
                                    search, &lt;i&gt;timeout&lt;/i&gt; can be used.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    If &lt;i&gt;readAttributesAsSelf&lt;/i&gt; is not set, the user attributes are collected from the search result. If
                                    it is set, an additional request is made after the second successful binding to retrieve the node's
                                    attributes.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element ref="staticUserDataProvider">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A &lt;i&gt;user data provider&lt;/i&gt; listing all user data in-place in the config file.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    the &lt;i&gt;staticuserdataprovider&lt;/i&gt; can be used to statically list user data within the config file.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    each user must have a unique &lt;i&gt;username&lt;/i&gt; attribute as well as a &lt;i&gt;password&lt;/i&gt; attribute.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    arbitrary attributes can be set on a user element. other sub-components of the &lt;i&gt;login&lt;/i&gt; interceptor
                                    might use those: for example, the &lt;i&gt;telekomsmstokenprovider&lt;/i&gt; uses the &lt;i&gt;sms&lt;/i&gt; property as the
                                    user's cell phone number. for example, the &lt;i&gt;totptokenprovider&lt;/i&gt; uses the &lt;i&gt;secret&lt;/i&gt; property to
                                    initialize the token sequence.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                        <xsd:element name="unifyingUserDataProvider" type="com.predic8.membrane.core.config.spring.UnifyingUserDataProviderParser">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                    The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; can be used to merge two or more other &lt;i&gt;user data providers&lt;/i&gt;
                                    into one.
                                    &lt;/p&gt;
                                    &lt;p&gt;
                                    The &lt;i&gt;unifyingUserDataProvider&lt;/i&gt; will forward a login attempt (username and password) to each inner
                                    user data provider in the order they are specified. After one of the inner user data providers returned
                                    a successful login (and returned the user's attributes), the procedure terminates. If no inner user data
                                    provider could verify the user, the login attempt fails.
                                    &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                        </xsd:element>
                    </xsd:choice>
                </xsd:sequence>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.StaticUserDataProvideruserParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="username" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's login.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="password" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's password.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="sms" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's phone number (if used in combination with the {@link TelekomSMSTokenProvider}).&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="secret" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The user's shared TOTP secret (if used in combination with the {@link TOTPTokenProvider}).&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:anyAttribute processContents="skip">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Other user attributes. For example any attribute starting with "&lt;i&gt;header&lt;/i&gt;" will be added
                            when HTTP requests are forwarded when authorized by this user.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:anyAttribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="userFeature">
        <xsd:annotation>
            <xsd:documentation></xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="validator">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="wsdl" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://predic8.com:8080/material/ArticleService?wsdl&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="schema" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The XSD Schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://www.predic8.com/schemas/order.xsd&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="failureHandler" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If "response", the HTTP response will include a detailled error message. If "log", the response will
                                be generic and the validation error will be logged.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; log&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; response&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="jsonSchema" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The JSON Schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; examples/validation/json-schema/schema2000.json&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="schematron" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The Schematron schema (URL or file) to validate against.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; examples/validation/schematron/car-schematron.xml&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="skipFaults" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to skip validation for SOAP fault messages.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wadlRewriter">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="protocol" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="port" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wsdlRewriter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="registryWSDLRegisterURL" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="protocol" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The protocol the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's protocol.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="host" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The host the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; localhost&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's host.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="port" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The port the endpoint should be changed to.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; 4000&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Don't change the endpoint's port.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wsdlPublisher">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                backend service does not already do so.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="wsdl" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The WSDL (URL or file).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; /WEB-INF/wsdl/ArticleService.wsdl&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="webServer">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                &lt;/p&gt;
                &lt;p&gt;
                The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                HTTP response with the contents of a file, or a "404 Not Found." error.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="docBase" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Sets path to the directory that contains the web content.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; docBase&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; docBase&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="index" type="xsd:string" >
                    </xsd:attribute>
                    <xsd:attribute name="generateIndex" type="spel_boolean" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="webServiceExplorer">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="wsdl" type="xsd:string" use="required">
                    </xsd:attribute>
                    <xsd:attribute name="portName" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="webSocket">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                After the upgrade, the connection's data packets are simply forwarded
                and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                    href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                    After the upgrade, the connection's data packets are simply forwarded
                                    and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element ref="wsLog">
                            </xsd:element>
                            <xsd:element ref="wsInterceptor">
                            </xsd:element>
                            <xsd:element ref="wsStompReassembler">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                    <xsd:attribute name="url" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The URL the WebSocket connection will be forwarded to. The (host,port) pair specifies the target server.
                                The (path,query) part are sent to the target server on the initial request. (For example, ActiveMQ listens on port
                                61614 and expects the incoming WebSocket connection to have a path '/' and empty query.)&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://localhost:61614/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wsLog">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="encoding" type="xsd:string" >
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wsInterceptor">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="refid" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Spring bean id of the referenced interceptor.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; myInterceptor&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="wsStompReassembler">
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="0" maxOccurs="unbounded">
                            <xsd:element ref="accessControl">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests whose origin TCP/IP address (hostname or IP address) is not allowed to access the
                                        requested resource.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="adminConsole">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Displays up-to-date statistics, recent exchanges and, by default, allows live modification of Membrane's configuration.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="apiKeyChecker">
                            </xsd:element>
                            <xsd:element ref="apiManagement">
                            </xsd:element>
                            <xsd:element ref="authHead2Body">
                            </xsd:element>
                            <xsd:element ref="basicAuthentication">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Blocks requests which do not have the correct RFC 1945 basic authentication credentials (HTTP header "Authentication: Basic ....").&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="cache">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Don't use, this does NOT implement valid HTTP caching.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        We currently just use this class to cache a bunch of Debian and Ubuntu Repositories as well as
                                        the Docker Registry for offline use.
                                        The cache does not revalidate any responses, so machines querying the cache for Debian
                                        package updates will be stuck in the past until the cache (on disk) is cleared manually. -
                                        This is - simply put - the only use case, where using this class makes any sense.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="clamav">
                            </xsd:element>
                            <xsd:element ref="clusterNotification">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Receives control messages to dynamically modify the configuration of a {@link LoadBalancingInterceptor}.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; See also examples/loadbalancer-client-2 in the Membrane Service Proxy distribution.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="if">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The "if" interceptor supports conditional execution of a group of executors.
                                        &lt;/p&gt;

                                        &lt;p&gt;
                                        Note that this is a draft implementation only: Design decissions are still pending.
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;'evaluate condition only once': Should the condition be reevaluated once response handling has begun?&lt;/li&gt;
                                        &lt;li&gt;'evaluate condition always during request handling already' (even when 'if' is nested in 'response')&lt;/li&gt;
                                        &lt;li&gt;What happens to ABORT handling of interceptor A in &lt;code&gt;&lt;request&gt;&lt;if test="..."&gt;&lt;A /&gt;&lt;/if&gt;&lt;/response&gt;&lt;/code&gt;&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="counter">
                            </xsd:element>
                            <xsd:element ref="dispatching">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; This interceptor adds the destination specified in the target
                                        element to the list of destinations of the exchange object. It
                                        must be placed into the transport to make Service Proxies Work
                                        properly. It has to be placed after the ruleMatching
                                        interceptor. The ruleMatching interceptor looks up a service
                                        proxy for an incoming request and places it into the exchange
                                        object. The dispatching interceptor needs the service proxy to
                                        get information about the target.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="exchangeStore">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Adds the current state of HTTP requests and responses to an "exchange store".&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that depending on the implementation of the exchange store, both request *and* response logging
                                        might both be required for the exchange to be saved.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="formValidation">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Using the formValidation interceptor you can validate the input of HTML forms.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="groovyTemplate">
                            </xsd:element>
                            <xsd:element ref="http2xml">
                            </xsd:element>
                            <xsd:element ref="httpClient">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The &lt;i&gt;httpClient&lt;/i&gt; sends the request of an exchange to a Web
                                        Server using the HTTP protocol. Usually it will be globally used
                                        inside the transport. However, it is also possible to use it
                                        inside a proxy to give the proxy an individual configuration for
                                        its outgoing HTTP connection that is different from the global
                                        configuration in the transport.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="headerFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Removes message headers matching a list of patterns.
                                        The first matching child element will be acted upon by the filter.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="index">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The index feature lists available proxys at a simple Web page.
                                        To use this feature just add a serviceProxy containing the index
                                        element. Of course you can protect the service proxy by using
                                        SSL or Username and Password.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="javascript">
                            </xsd:element>
                            <xsd:element ref="limit">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Limits the maximum length of a HTTP message body.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that due to the streaming nature of Membrane, a request header may already have been passed on to
                                        the backend, when the condition "body.length &gt; X" becomes true. In this case, further processing is
                                        aborted and the connection to the backend is simply closed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        To apply &lt;tt&gt;&lt;limit/&gt;&lt;/tt&gt; only to either requests or responses, wrap it in a corresponding tag:
                                        &lt;tt&gt;&lt;request&gt;&lt;limit ... /&gt;&lt;/request&gt;&lt;/tt&gt;.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="balancer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 7. Clustering and Loadbalancing&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Performs load-balancing between several nodes. Nodes sharing session state may be bundled into a cluster.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; May only be used as interceptor in a ServiceProxy.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="log">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The log feature logs request and response messages to the log4j
                                        framework. The messages will appear either on the console or in
                                        a log file depending on the configuration of the
                                        &lt;i&gt;conf/log4j.properties&lt;/i&gt; file.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="login">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor can be used to restrict and secure end user access to an arbitrary web
                                        application.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Users firstly have to authenticate themselves against a directory server using a username and password.
                                        Secondly, a numeric token is then sent to the user's cell phone using a text message service. After
                                        token verification, access to the web application is granted for the user's session. Single Sign On can
                                        easily be realized using a small source code extension or modification of a web application.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor combines 4 modules to implement its functionality. One implementation of
                                        each of the 4 module types is required. (The &lt;i&gt;session manager&lt;/i&gt; and &lt;i&gt;account blocker&lt;/i&gt; have
                                        default implementations.)
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;user data provider&lt;/i&gt; checks user passwords and provides additional data for each user (e.g.
                                        cell phone number, Single Sign On data, etc.).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;session manager&lt;/i&gt; tracks the users' sessions across different HTTP requests (e.g. using a
                                        session cookie).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;account blocker&lt;/i&gt; tracks the number of failed login attempts and might block future login
                                        attempts for a specified amount of time.
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;li&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;token provider&lt;/i&gt; generates the numeric token (possibly transmitting it to the user via a
                                        secondary channel like text messaging).
                                        &lt;/p&gt;
                                        &lt;/li&gt;
                                        &lt;/ul&gt;
                                        &lt;p&gt;
                                        &lt;img style="align:center; padding: 20px;" src="/images/doc/login.png" alt="login interceptor workflow"
                                        title="login interceptor workflow"/&gt;
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        (Whether text messages and LDAP is actually used depends on the configuration. Alternatives are
                                        possible.)
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;login&lt;/i&gt; interceptor realizes the login workflow. If all information entered by the user is
                                        valid, the workflow is as follows:
                                        &lt;/p&gt;
                                        &lt;ul&gt;
                                        &lt;li&gt;The unauthenticated user is redirected to a login dialog.&lt;/li&gt;
                                        &lt;li&gt;The user enters her username and password. (Step 1.)&lt;/li&gt;
                                        &lt;li&gt;(A numeric token is sent to the user via text message, in case the &lt;i&gt;telekomSMSTokenProvider&lt;/i&gt; is
                                        used. Steps 5 and 6.)&lt;/li&gt;
                                        &lt;li&gt;The user enters her token. (Step 7.)&lt;/li&gt;
                                        &lt;li&gt;The user is redirected to the originally requested URL (or a generic URL, in case the login dialog
                                        was directly requested). (Step 8.)&lt;/li&gt;
                                        &lt;/ul&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="analyser">
                            </xsd:element>
                            <xsd:element ref="methodOverride">
                            </xsd:element>
                            <xsd:element ref="oauth2authserver">
                            </xsd:element>
                            <xsd:element ref="oauth2Resource">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows only authorized HTTP requests to pass through. Unauthorized requests get a redirect to the
                                        authorization server as response.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tokenValidator">
                            </xsd:element>
                            <xsd:element ref="prometheus">
                            </xsd:element>
                            <xsd:element ref="rest2Soap">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts REST requests into SOAP messages.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rateLimiter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows rate limiting (Experimental)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="regExReplacer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Runs a regular-expression-replacement on either the message body (default) or all header values.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="accountRegistration">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allows account registration (!Experimental!)&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="request" type="com.predic8.membrane.core.config.spring.RequestParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;request&gt; Element you can limit their applictaion to requests only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element name="response" type="com.predic8.membrane.core.config.spring.ResponseParser">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Interceptors are usually applied to requests and responses. By nesting interceptors into a
                                        &lt;response&gt; Element you can limit their applictaion to responses only.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="reverseProxying">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Rewrites the scheme, hostname and port in the "Location" header in HTTP responses,
                                        as well as in the "Destination" header in HTTP requests. The rewriting reflects the different schemes,
                                        hostnames and ports used to access Membrane Service Proxy vs. the target HTTP server.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="rewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Rewrites the path of incoming requests based on a mapping or redirects requests.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="ruleMatching">
                            </xsd:element>
                            <xsd:element ref="soap2Rest">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Converts SOAP messages into REST requests.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="soapStackTraceFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; removes SOAP stack traces from message bodies.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Using this interceptor hides sensitive information, as the structure of your backend source code, from the caller.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The &lt;i&gt;soapStackTraceFilter&lt;/i&gt; works without further configuration with most backend servers, but it is
                                        advised to test its functionality in combination with your SOAP service provider before deploying it in
                                        production.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="spdy">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="https://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1"&gt;SPDY protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="stompClient">
                            </xsd:element>
                            <xsd:element ref="soapOperationExtractor">
                            </xsd:element>
                            <xsd:element ref="interceptor">
                            </xsd:element>
                            <xsd:element ref="statisticsCSV">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a CSV
                                        file (one line per exchange).&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; Note that the CSV file is UTF-8 encoded.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsJDBC">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 5. Monitoring, Logging and Statistics&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Writes statistics (time, status code, hostname, URI, etc.) about exchanges passing through into a
                                        database (one row per exchange).&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="statisticsProvider">
                            </xsd:element>
                            <xsd:element ref="swaggerApiKeyRequirer">
                            </xsd:element>
                            <xsd:element ref="swaggerRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow Swagger proxying&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="tcp">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc793"&gt;TCP protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="testService">
                            </xsd:element>
                            <xsd:element ref="throttle">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The throttle feature can slow down traffic to thwart denial of service attacks.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="urlNormalizer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Replaces "/./" in the request URI's path by "/".
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        Necessary, as old SOA model versions do not normalize URIs before requesting them. Our WSDLPublisher
                                        links to XSD Schemas using relative paths (as we want the links to work under any servlet's context
                                        root). The SOA model then combines "http://foo/material/ArticleService?wsdl" and
                                        "./ArticleService?xsd=1" to "http://foo/material/./ArticleService?xsd=1". This URI is sent to Membrane's
                                        new soapProxy which has configured a serviceProxy-path of "\Q/material/ArticleService\E.*" which does
                                        not match.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="userFeature">
                                <xsd:annotation>
                                    <xsd:documentation></xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="validator">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wadlRewriter">
                            </xsd:element>
                            <xsd:element ref="wsdlRewriter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;The &lt;i&gt;wsdlRewriter&lt;/i&gt; rewrites endpoint addresses of services and XML Schema locations in WSDL documents.&lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="wsdlPublisher">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 8. SOAP based Web Services&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;wsdlPublisher&lt;/i&gt; can be used to serve WSDL files (and attached XML Schema Documents), if your
                                        backend service does not already do so.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServer">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 4. Interceptors/Features&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Serves static files based on the request's path.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        Note that &lt;i&gt;docBase&lt;/i&gt; any &lt;i&gt;location&lt;/i&gt;: A relative or absolute directory, a
                                        "classpath://com.predic8.membrane.core.interceptor.administration.docBase" expression or a URL.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        The interceptor chain will not continue beyond this interceptor, as it either successfully returns a
                                        HTTP response with the contents of a file, or a "404 Not Found." error.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="webServiceExplorer">
                            </xsd:element>
                            <xsd:element ref="webSocket">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Allow HTTP protocol upgrades to the &lt;a
                                        href="http://tools.ietf.org/html/rfc6455"&gt;WebSocket protocol&lt;/a&gt;.
                                        After the upgrade, the connection's data packets are simply forwarded
                                        and not inspected.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; false&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlContentFilter">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                                        using an XPath expression.
                                        &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                                        match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                                        to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                                        lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                                        namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                                        &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                                        the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                                        constructed.
                                        &lt;/p&gt;
                                        &lt;p&gt;
                                        If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                                        XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                                        modified reconstituted message.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="xmlProtection">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                                        attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="switch">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                            <xsd:element ref="transform">
                                <xsd:annotation>
                                    <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                                        The transform feature applies an XSLT transformation to the content in the body of a message. After the
                                        transformation the body content is replaced with the result of the transformation.
                                        &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
                                </xsd:annotation>
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:complexType name="com.predic8.membrane.core.config.spring.WhateverMobileSMSTokenProviderParser">
        <xsd:complexContent >
            <xsd:extension base="beans:identifiedType">
                <xsd:sequence>
                </xsd:sequence>
                <xsd:attribute name="prefixText" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; A string that will be prepended to the token when creating the text message.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; "Token: "&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="simulate" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Don't send any text messages, only write tokens to the log.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="gatewayUserName" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Your whatevermobile.com gateway user name.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="gatewayPassword" type="xsd:string" use="required">
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Your whatevermobile.com gateway password.&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="senderName" type="xsd:string" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; The sender name of the text messages. This string is displayed as the sender on the recipient's phone.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; Your Organization Name&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; Membrane&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
                <xsd:attribute name="backupServiceAvailable" type="spel_boolean" >
                    <xsd:annotation>
                        <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specify whether the alternative gateway is available for the configured account&lt;br/&gt;</xsd:documentation>
                    </xsd:annotation>
                </xsd:attribute>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    <xsd:element name="xmlContentFilter">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The &lt;i&gt;xmlContentFilter&lt;/i&gt; removes certain XML elements from message bodies. The elements are described
                using an XPath expression.
                &lt;/p&gt;&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Explanation:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                If the XPath expression is simple enough, a StAX-Parser is used to determine whether the XPath might
                match a message at all. This can improve performance significantly, as a DOM tree does probably not have
                to to be constructed for every message. This is, for example, the case in &lt;listing name="example"&gt; &lt;src
                lang="xml"&gt; &lt;xmlContentFilter xPath=&quot;//*[local-name()='Fault' and
                namespace-uri()='http://schemas.xmlsoap.org/soap/envelope/']//*[local-name()='stacktrace']&quot; /&gt;
                &lt;/src&gt; &lt;caption&gt;xmlContentFilter using a StAX-Parser for improved performance&lt;/caption&gt; &lt;/listing&gt; where
                the existence of the &lt;Fault&gt;-element is checked using the StAX-parser before the DOM is
                constructed.
                &lt;/p&gt;
                &lt;p&gt;
                If the message body is not well-formed XML, it is left unchanged. If the message is XOP-encoded, the
                XPath-expression is run on the reconstituted message; if it matches, the message is replaced by the
                modified reconstituted message.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="xPath" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; An XPath 1.0 expression describing the elements to be removed from message bodies.&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="xmlSessionIdExtractor">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Extracts a session ID from an XML HTTP request body based on the qualified name of an XML element.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="localName" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies local name of session element.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; session&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="namespace" type="xsd:string" use="required">
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Specifies namespace of session element.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; http://chat.predic8.com/&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="xmlProtection">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 6. Security&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Prohibits XML documents to be passed through that look like XML attacks on older parsers. Too many
                attributes, too long element names are such indications. DTD definitions will simply be removed.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="maxAttibuteCount" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If an incoming request exceeds this limit, it will be discarded.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="maxElementNameLength" type="spel_number" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; If an incoming request exceeds this limit, it will be discarded.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; 1000&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                    <xsd:attribute name="removeDTD" type="spel_boolean" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Whether to remove the DTD from incoming requests.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Default:&lt;/b&gt;&lt;/h3&gt; true&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="switch">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                        <xsd:choice minOccurs="1" maxOccurs="unbounded">
                            <xsd:annotation>
                                <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Changes an exchange's target based on a series of XPath expressions.&lt;br/&gt;</xsd:documentation>
                            </xsd:annotation>
                            <xsd:element name="case" type="com.predic8.membrane.core.config.spring.SwitchcaseParser">
                            </xsd:element>
                        </xsd:choice>
                    </xsd:sequence>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
    <xsd:element name="transform">
        <xsd:annotation>
            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Topic:&lt;/b&gt;&lt;/h3&gt; 3. Enterprise Integration Patterns&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; &lt;p&gt;
                The transform feature applies an XSLT transformation to the content in the body of a message. After the
                transformation the body content is replaced with the result of the transformation.
                &lt;/p&gt;&lt;br/&gt;</xsd:documentation>
        </xsd:annotation>
        <xsd:complexType>
            <xsd:complexContent >
                <xsd:extension base="beans:identifiedType">
                    <xsd:sequence>
                    </xsd:sequence>
                    <xsd:attribute name="xslt" type="xsd:string" >
                        <xsd:annotation>
                            <xsd:documentation>&lt;h3&gt;&lt;b&gt;Description:&lt;/b&gt;&lt;/h3&gt; Location of the XSLT stylesheet that will be applied to request and response.&lt;br/&gt;&lt;h3&gt;&lt;b&gt;Example:&lt;/b&gt;&lt;/h3&gt; strip.xslt&lt;br/&gt;</xsd:documentation>
                        </xsd:annotation>
                    </xsd:attribute>
                </xsd:extension>
            </xsd:complexContent>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>